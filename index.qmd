---
title: "How far can you really see the drone?"
format: 
  html:
    code-fold: true
execute:
  warning: false

editor: visual
---

# Introduction

Maintaining visual line of sight (VLOS) of a drone is a fundamental requirement under 14 CFR Part 107, which governs the commercial use of small unmanned aircraft systems (sUAS) in the United States. According to these regulations, drone pilots (or their visual observers) must always be able to see their aircraft unaided by any device other than corrective lenses. This requirement serves as a critical safety measure: by keeping the drone in sight, operators can better avoid collisions with buildings, power lines, or other aircraft, and can respond more quickly to unexpected events or emergencies.

In practical terms, “visual line of sight” means that the operator or observer can clearly identify the drone’s orientation and location in real time. While this may sound straightforward, factors such as distance, weather conditions, obstacles, and lighting can all compromise VLOS. Consequently, ensuring VLOS compliance across varying operational scenarios is not always a simple task.

Despite its importance, relatively little research has been dedicated to developing systematic methods to estimate or verify VLOS. Most current industry practices rely on manual observation and conservative flight planning to ensure the drone remains within sight, but these approaches can be subjective and prone to human error.

```{r, echo=FALSE, warning=FALSE}
library(ggplot2)
library(plotly)
library(readxl)
library(pROC)
library(dplyr)
library(tidyverse)
library(forcats)
library(gt)
library(emmeans)
library(kableExtra)
```

```{r echo=FALSE}
source("shared.R")

```

```{r echo=FALSE}
#' Calculate Minimum Visibility
#'
#' This function calculates the minimum visibility distance given a size of the drone (2D dimensions), an altitude and the desired acuity (in arc minutes).
#'
#' @param size A numeric vector of length 2, representing size dimensions (x and y).
#' @param alt A numeric value representing the altitude.
#' @param acuity A numeric value representing the desired acuity (in arc minutes)
#' @return The minimum visibility distance as a numeric value.
#' @examples
#' calculateMinimumVisibility(c(10, 20), 50, 6)
calculateMinimumVisibility <- function(size = c(4.2,11.3) , alt=50, acuity=6) {
  # Input validation
  if (!is.numeric(size) || length(size) != 2) {
    stop("Invalid input: 'size' must be a numeric vector of length 2.")
  }
  if (!is.numeric(alt) || length(alt) != 1) {
    stop("Invalid input: 'alt' must be a single numeric value.")
  }
  if (!is.numeric(acuity) || length(acuity) != 1) {
    stop("Invalid input: 'acuity' must be a single numeric value.")
  }
  
  #Extract
  x <- size[1]/12 # Convert inches to ft
  y <- size[2]/12 # Convert inches to ft
  minT <- acuity / 60 * pi / 180 # Convert arcminutes to radians
  
  # Initialize variables
  theta_c <- 1
  distance <- 0
  #What is the largest value that distance can be before the viewing angle of the drone drops below the target acuity
  while (theta_c > minT) {
    # Check in increments of 2
    distance <- distance + 2
    a <- c(distance - y / 2, alt + x / 2)
    b <- c(distance + y / 2, alt - x / 2)
    
    # Compute the dot product and norms
    num1 <- sum(a * b)
    den1 <- sqrt(sum(a^2)) * sqrt(sum(b^2))
    
    # Calculate the angle
    theta_c <- acos(num1 / den1)
  }
  # Return the distance
  return(distance)
}
```

```{r echo=FALSE}
#' Calculate VLOS based on EASA Guidelines (Oct 2024) 
#'
#' This function calculates VLOS using the EASA Guidelines (https://www.easa.europa.eu/en/downloads/139435/en)
#'
#' @param size A numeric vector of length 2, representing size dimensions (x and y).
#' @param fixedWing A boolean representing whether the drone is a fixed-wing type drone
#' @return The minimum visibility distance as a numeric value.
#' @examples
#' calculateEUDronePortVLOS(c(10, 20), FALSE)
calculateEASAVLOS <- function(size = c(4.2,11.3) , fixedWing = FALSE) {
  # Input validation
  if (!is.numeric(size) || length(size) != 2) {
    stop("Invalid input: 'size' must be a numeric vector of length 2.")
  }
  if (!is.logical(fixedWing) || length(fixedWing) != 1) {
    stop("Invalid input: 'fixedWing' must be a logical vector of length 1.")
  }
  
  
  #Extract
  x <- size[1]/12 # Convert inches to ft
  y <- size[2]/12 # Convert inches to ft
  
  
  # Meter conversion
  m2ft <- 3.280839895
  
  distance <- 0
  
  if (fixedWing){
    CD <- max(x,y)
    distance <- 490*m2ft*CD/m2ft + 30*m2ft
  } else {
    CD <- sqrt(max(x,y)^2+max(x,y)^2)
    distance <- 327*m2ft*CD/m2ft + 20*m2ft
  }
  
  
  return(distance)
}
```

```{css echo=FALSE}
/* Container for the input form */
body {
  font-family: 'Roboto', sans-serif;
}

/* Container for the input form */
.input-container {
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  max-width: 800px;
  margin: 20px auto;
  padding: 20px;
  border: 1px solid #ddd;
  border-radius: 8px;
  background-color: #f9f9f9;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
  gap: 20px; /* Space between input groups */
}

.input-group {
  display: flex;
  flex-direction: column;
  flex: 1; /* Allow input groups to expand evenly */
}

.input-group label {
  display: flex;
  font-size: 14px;
  align-items: center;
  margin-bottom: 5px;
  font-weight: 600;
  color: #333;
}

.input-group label i {
  margin-right: 5px;
  color: #007BFF;
}

.input-group input,
.input-group select {
  padding: 8px 10px;
  border: 1px solid #ccc;
  border-radius: 4px;
  font-size: 12px;
  transition: border-color 0.3s, box-shadow 0.3s;
  max-width: 120px; /* Restrict width */
}

.input-group input[type="number"] {
  width: 100%;
}

.input-group input:focus,
.input-group select:focus {
  border-color: #007BFF;
  box-shadow: 0 0 5px rgba(0, 123, 255, 0.5);
  outline: none;
}

/* Restrict number inputs to 5 digits 
.input-group input[type="number"]::-webkit-inner-spin-button, 
.input-group input[type="number"]::-webkit-outer-spin-button { 
  -webkit-appearance: none; 
  margin: 0; 
}*/

.input-group input[type="number"] {
  -moz-appearance: textfield;
}

/* Responsive adjustments */
@media (max-width: 800px) {
  .input-container {
    flex-direction: column;
    max-width: 400px;
  }

  .input-group {
    width: 100%;
  }

  .input-group input,
  .input-group select {
    max-width: 100%;
  }
}

/* Helper text styling */
.input-group small {
  color: #666;
  margin-top: 5px;
  font-size: 10px;
}
```

An example of for a multi-rotor drone (Autel Evo II v3) and a fixed-wing drone (AgEagle eBee) can be found below. A third panel provides the user with an interactive UI to enter in an arbitrary drone size and type for analysis.

::: panel-tabset
## Autel Evo II v3 Example

```{r echo=FALSE}
# Define parameters
x <- 4.33
y <- 13.9
size <- c(x, y)
drone_type = FALSE

# Define maximum altitude
maxAlt <- 400  # Replace 400 with your desired maximum altitude

# Define acuity
acuity_safe <- 6
acuity_max <-3
acuity_bad <-1

# Preallocate lines
safe_D <- numeric(maxAlt)
max_D <- numeric(maxAlt)
bad_D <- numeric(maxAlt)

# Loop through altitudes and compute minD
for (alt in 1:maxAlt) {
  safe_D[alt] <- calculateMinimumVisibility(size, alt, acuity_safe)
  max_D[alt] <- calculateMinimumVisibility(size, alt, acuity_max)
  bad_D[alt] <- calculateMinimumVisibility(size, alt, acuity_bad)
}

# Calcualte EU Drone Port
distance_EU = calculateEASAVLOS(size,drone_type)

# Create a data frame
data_safe <- data.frame(
  distance = safe_D,
  altitude = 1:maxAlt
)

# Create a data frame
data_max <- data.frame(
  distance = max_D,
  altitude = 1:maxAlt
)

# Create a data frame for plotting
data_bad <- data.frame(
  distance = bad_D,
  altitude = 1:maxAlt
)

# Create an interactive plot
plotly_plot <- plot_ly(
    data_safe, 
    x = ~distance, 
    y = ~altitude, 
    type = 'scatter', 
    mode = 'lines', 
    name = "Safe Distance",
    line=list(color="green")
    ) %>%
  add_trace(
    data = data_max, 
    x = ~distance, 
    y = ~altitude, 
    type = 'scatter', 
    mode = 'lines', 
    name="Max Distance",
    line=list(color="blue")
    ) %>%
  add_trace(
    data = data_bad, 
    x = ~distance, 
    y = ~altitude, 
    type = 'scatter', 
    mode = 'lines', 
    name="Limit of Human Vision", 
    line=list(color="red")
    ) %>%
  add_trace(
    x = c(distance_EU, distance_EU), 
    y = c(0, 400),  # Vertical line coordinates
    type = 'scatter', mode = 'lines',
    name = "EASA Guidelines",  # Legend label
    line = list(color = "black", dash = "dash", width = 2)
    ) %>%
  layout(
    title = "Visual Line of Sight Estimator",
    xaxis = list(title = "Minimum Distance"),
    yaxis = list(title = "Altitude", range=c(0,400)),
    legend = list(
      orientation = "h",  # Horizontal legend
      x = 0.5,            # Centered horizontally
      y = -0.2,           # Positioned below the plot
      xanchor = "center"  # Align the legend horizontally
    ),
    margin = list(l = 50, r = 50, b = 100, t = 50)
  )

plotly_plot
```

While the EASA guidelines suggest a max visibility range of `r round(distance_EU)` ft, the use of visual acuity presents a recommended distance of no more than `r max(max_D)` ft with the limit of the average human's vision at `r max(bad_D)` ft.

## AgEagle eBee Example

```{r echo=FALSE}
# Define parameters
x <- 4.3
y <- 45.7
size <- c(x, y)
drone_type = TRUE

# Define maximum altitude
maxAlt <- 400  # Replace 400 with your desired maximum altitude

# Define acuity
acuity_safe <- 6
acuity_max <-3
acuity_bad <-1

# Preallocate lines
safe_D <- numeric(maxAlt)
max_D <- numeric(maxAlt)
bad_D <- numeric(maxAlt)

# Loop through altitudes and compute minD
for (alt in 1:maxAlt) {
  safe_D[alt] <- calculateMinimumVisibility(size, alt, acuity_safe)
  max_D[alt] <- calculateMinimumVisibility(size, alt, acuity_max)
  bad_D[alt] <- calculateMinimumVisibility(size, alt, acuity_bad)
}

# Calcualte EU Drone Port
distance_EU = calculateEASAVLOS(size,drone_type)

# Create a data frame
data_safe <- data.frame(
  distance = safe_D,
  altitude = 1:maxAlt
)

# Create a data frame
data_max <- data.frame(
  distance = max_D,
  altitude = 1:maxAlt
)

# Create a data frame for plotting
data_bad <- data.frame(
  distance = bad_D,
  altitude = 1:maxAlt
)

# Create an interactive plot
plotly_plot <- plot_ly(
    data_safe, 
    x = ~distance, 
    y = ~altitude, 
    type = 'scatter', 
    mode = 'lines', 
    name = "Safe Distance",
    line=list(color="green")
    ) %>%
  add_trace(
    data = data_max, 
    x = ~distance, 
    y = ~altitude, 
    type = 'scatter', 
    mode = 'lines', 
    name="Max Distance",
    line=list(color="blue")
    ) %>%
  add_trace(
    data = data_bad, 
    x = ~distance, 
    y = ~altitude, 
    type = 'scatter', 
    mode = 'lines', 
    name="Limit of Human Vision", 
    line=list(color="red")
    ) %>%
  add_trace(
    x = c(distance_EU, distance_EU), 
    y = c(0, 400),  # Vertical line coordinates
    type = 'scatter', mode = 'lines',
    name = "EASA Guidelines",  # Legend label
    line = list(color = "black", dash = "dash", width = 2)
    ) %>%
  layout(
    title = "Visual Line of Sight Estimator",
    xaxis = list(title = "Minimum Distance"),
    yaxis = list(title = "Altitude", range=c(0,400)),
    legend = list(
      orientation = "h",  # Horizontal legend
      x = 0.5,            # Centered horizontally
      y = -0.2,           # Positioned below the plot
      xanchor = "center"  # Align the legend horizontally
    ),
    margin = list(l = 50, r = 50, b = 100, t = 50)
  )

plotly_plot
```

The variation is significant when comparing results for fixed-wing UAS. The EASA guidelines suggest a max visibility range of `r round(distance_EU)` ft, the use of visual acuity presents a recommended distance of no more than `r max(max_D)` ft with the limit of the average human's vision at `r max(bad_D)` ft.

## Interactive Example

```{=html}
<!--
  Inputs for dimension X, dimension Y, and Drone Type (Multirotor vs. Fixed-Wing)
  Adjust these controls as desired (sliders, numeric inputs, etc.).
-->
<div class="input-container">
  <div class="input-group">
    <label for="dimX"><i class="fas fa-arrows-alt-v"></i> Vertical (inches):</label>
    <input type="number" id="dimX" name="dimX" value="4.2" step="0.1" min="0" max="99999" placeholder="e.g., 4.2" oninput="updatePlot()" aria-describedby="dimX-help" />
    <small id="dimX-help">Enter the vertical height of the drone in inches.</small>
  </div>

  <div class="input-group">
    <label for="dimY"><i class="fas fa-arrows-alt-h"></i> Horizontal (inches):</label>
    <input type="number" id="dimY" name="dimY" value="11.3" step="0.1" min="0" max="99999" placeholder="e.g., 11.3" oninput="updatePlot()" aria-describedby="dimY-help" />
    <small id="dimY-help">Enter the horizontal width or length of the drone in inches.</small>
  </div>

  <div class="input-group">
    <label for="droneType"><i class="fas fa-drone"></i> Drone Type:</label>
    <select id="droneType" name="droneType" onchange="updatePlot()" aria-describedby="droneType-help">
      <option value="FALSE" selected>Multirotor (default)</option>
      <option value="TRUE">Fixed-Wing</option>
    </select>
    <small id="droneType-help">Select the type of drone.</small>
  </div>
</div>

<!-- Plot container -->
<div id="plot" style="width:100%; height:400px;"></div>

<script>
  // ---------------------------
  // 1. R -> JavaScript Conversion
  // ---------------------------

  // JS version of `calculateMinimumVisibility(size, alt, acuity)`
  // Replicates the "while" loop that increments `distance` until the angle is below the threshold.
  function calculateMinimumVisibility(size, alt, acuity) {
    // Convert inches to feet
    const xFeet = size[0] / 12;
    const yFeet = size[1] / 12;

    // Acuity in arc minutes -> radians
    const minT = (acuity / 60) * (Math.PI / 180);

    let theta_c = 1.0;
    let distance = 0.0;

    while (theta_c > minT) {
      distance += 2; // increment by 2 feet each loop

      // a = c(distance - y/2, alt + x/2)
      const a = [distance - yFeet / 2, alt + xFeet / 2];
      // b = c(distance + y/2, alt - x/2)
      const b = [distance + yFeet / 2, alt - xFeet / 2];

      // Dot product & norms
      const num1 = a[0] * b[0] + a[1] * b[1];
      const den1 =
        Math.sqrt(a[0] * a[0] + a[1] * a[1]) *
        Math.sqrt(b[0] * b[0] + b[1] * b[1]);

      theta_c = Math.acos(num1 / den1);
    }

    return distance;
  }

  // JS version of `calculateEASAVLOS(size, fixedWing)`
  function calculateEASAVLOS(size, fixedWing) {
    // Convert inches to feet
    const xFeet = size[0] / 12;
    const yFeet = size[1] / 12;
    const CD = Math.sqrt(xFeet * xFeet + yFeet * yFeet);

    const m2ft = 3.280839895; // meter to feet conversion
    let distance = 0;

    if (fixedWing) {
    
      distance = 490*m2ft*CD/m2ft + 30*m2ft;
    } else {
      distance = 327*m2ft*CD/m2ft + 20*m2ft;
    }

    return distance;
  }

  // ---------------------------
  // 2. Main Update/Plot Routine
  // ---------------------------
  function updatePlot() {
    // Retrieve user inputs
    const dimX = parseFloat(document.getElementById("dimX").value);
    const dimY = parseFloat(document.getElementById("dimY").value);
    const droneType = document.getElementById("droneType").value === "TRUE";

    // Prepare inputs for our JS functions
    const size = [dimX, dimY];
    const maxAlt = 600; // we loop from altitude = 1 to 400 (feet)
    
    // Different acuities
    const acuitySafe = 6;
    const acuityMax = 3;
    const acuityBad = 1;

    // Arrays to store results for each altitude
    const safeD = [];
    const maxD = [];
    const badD = [];

    // alt axis from 1..400 for plotting
    const altitudes = Array.from({ length: maxAlt }, (_, i) => i + 1);

    // Compute distances for each altitude
    for (let alt = 1; alt <= maxAlt; alt++) {
      safeD.push(calculateMinimumVisibility(size, alt, acuitySafe));
      maxD.push(calculateMinimumVisibility(size, alt, acuityMax));
      badD.push(calculateMinimumVisibility(size, alt, acuityBad));
    }

    // Compute the EASA guideline distance
    const distanceEU = calculateEASAVLOS(size, droneType);

    // Build Plotly data
    const traceSafe = {
      x: safeD,
      y: altitudes,
      type: "scatter",
      mode: "lines",
      name: "Safe Distance",
      line: { color: "green" }
    };
    const traceMax = {
      x: maxD,
      y: altitudes,
      type: "scatter",
      mode: "lines",
      name: "Max Distance",
      line: { color: "blue" }
    };
    const traceBad = {
      x: badD,
      y: altitudes,
      type: "scatter",
      mode: "lines",
      name: "Limit of Human Vision",
      line: { color: "red" }
    };
    const traceEU = {
      x: [distanceEU, distanceEU],
      y: [0, maxAlt],
      type: "scatter",
      mode: "lines",
      name: "EASA Guidelines",
      line: { color: "black", dash: "dash", width: 2 }
    };
    const traceAlt400 = {
      x: [0, Math.max(...safeD, ...maxD, ...badD, distanceEU)],
      y: [400,400],
      type: "scatter",
      mode: "lines",
      name: "400 ft AGL",
      line: { color: "black", dash: "dot", width: 2 }
    };
      
    

    // Plotly Layout
    const layout = {
      title: "Visual Line of Sight Estimator",
      xaxis: { title: "Minimum Distance (feet)",
               rangemode: "tozero"  // always start at 0
              },
      yaxis: { title: "Altitude (feet)", range: [0, maxAlt] },
      legend: {
        orientation: "h",
        x: 0.5,
        y: -0.2,
        xanchor: "center"
      },
      margin: { l: 50, r: 50, b: 100, t: 50 }
    };

    // Render/Update the Plotly plot
    Plotly.newPlot("plot", [traceSafe, traceMax, traceBad, traceEU, traceAlt400], layout);
  }

  // Initialize the plot on page load
  document.addEventListener("DOMContentLoaded", updatePlot);
</script>
```
:::
